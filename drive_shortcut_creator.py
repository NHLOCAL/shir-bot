import os
import certifi # Keep for potential direct SSL context needs if runners change
import time
import json # Needed for parsing JSON from environment variables
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials # Main object we'll build
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# --- הגדרות ---
# SCOPES must match the scopes used when the token in GOOGLE_TOKEN_JSON was generated
SCOPES = ['https://www.googleapis.com/auth/drive'] 

# File names are no longer directly used by authenticate
# CLIENT_SECRET_FILE = 'client_secret_auth.json' # No longer read
# TOKEN_FILE = 'token.json' # No longer read

# --- IDs remain the same ---
SOURCE_ROOT_FOLDER_ID = "1sMGZLisLMAZKKeCVnkGREZbUW7aXst08"
TARGET_ROOT_FOLDER_ID = "1dfyehiuGrgj2B_76-9I-nJqJ3VOLP3v_"
SINGLES_FOLDER_NAME = "סינגלים"
# --- סוף הגדרות ---

def authenticate():
    """
    Authenticates using credentials data loaded directly from environment variables.
    Refreshes the token if necessary. Does NOT perform interactive auth or read files.
    """
    creds = None
    
    # 1. Read credential data from environment variables
    client_secret_json_str = os.environ.get('GOOGLE_CLIENT_SECRET_JSON')
    token_json_str = os.environ.get('GOOGLE_TOKEN_JSON')

    if not client_secret_json_str:
        print("Error: Environment variable GOOGLE_CLIENT_SECRET_JSON is not set.")
        return None
    if not token_json_str:
        print("Error: Environment variable GOOGLE_TOKEN_JSON is not set.")
        return None

    try:
        # 2. Parse the JSON strings
        client_config = json.loads(client_secret_json_str)
        # Client secrets are usually nested under 'installed' or 'web'
        if 'installed' in client_config:
            client_info = client_config['installed']
        elif 'web' in client_config:
             client_info = client_config['web']
        else:
             print("Error: Could not find 'installed' or 'web' key in client secret JSON.")
             return None

        token_info = json.loads(token_json_str)

        # 3. Extract necessary info and build Credentials object
        # Ensure required keys exist in the parsed token info
        required_keys = ['refresh_token', 'token_uri', 'client_id', 'client_secret', 'scopes']
        if not all(key in token_info for key in required_keys):
             print(f"Error: Missing one or more required keys in token JSON: {required_keys}")
             # Optionally print which keys are missing
             # print(f"Available keys: {list(token_info.keys())}")
             return None

        # Use info primarily from token_info as it's generated by the flow
        # Client info is mainly for validation or if token_info lacks client details
        creds = Credentials(
            token=None, # Start with None, rely on refresh token
            refresh_token=token_info['refresh_token'],
            token_uri=token_info['token_uri'],
            client_id=token_info['client_id'],
            client_secret=token_info['client_secret'],
            scopes=token_info['scopes'] # Use scopes from the token
        )

        # Verify client ID consistency (optional but good practice)
        if creds.client_id != client_info.get('client_id'):
             print("Warning: Client ID mismatch between token data and client secret data.")
             # Decide if this is a fatal error for your use case
             # return None 

        # 4. Check validity and refresh if needed
        # It's good practice to explicitly check and refresh after manual creation
        if not creds.valid:
            if creds.expired and creds.refresh_token:
                print("Credentials expired. Attempting to refresh token...")
                try:
                    creds.refresh(Request())
                    print("Token refreshed successfully.")
                except Exception as e:
                    print(f"Error refreshing token: {e}")
                    print("Refresh token might be invalid or revoked.")
                    print("Generate a new token.json locally and update the GOOGLE_TOKEN_JSON secret.")
                    return None # Critical failure in Actions
            else:
                print("Credentials are not valid and cannot be refreshed (or no refresh token).")
                return None # Critical failure

    except json.JSONDecodeError as e:
        print(f"Error decoding JSON from environment variable: {e}")
        if 'GOOGLE_TOKEN_JSON' in str(e): # Crude check which variable failed
             print("-> Check the content of the GOOGLE_TOKEN_JSON secret in GitHub.")
        elif 'GOOGLE_CLIENT_SECRET_JSON' in str(e):
              print("-> Check the content of the GOOGLE_CLIENT_SECRET_JSON secret in GitHub.")
        return None
    except KeyError as e:
        print(f"Error: Missing expected key {e} in parsed JSON data.")
        print("-> Ensure the secrets contain complete and valid JSON.")
        return None
    except Exception as e:
         print(f"An unexpected error occurred during authentication setup: {e}")
         return None


    return creds

# --- Helper functions (list_items, create_folder, create_shortcut) ---
# --- and main process_drive_structure() function remain the same ---
# --- Make sure they are included below this point in your actual file ---

# --- [ PASTE list_items, create_folder, create_shortcut functions here ] ---
def list_items(service, query, fields="nextPageToken, files(id, name, mimeType)"):
    # ... (implementation as before) ...
    items = []
    page_token = None
    while True:
        try:
            response = service.files().list(
                q=query,
                spaces='drive',
                fields=fields,
                pageToken=page_token,
                 # Add Shared Drive support if needed (uncomment):
                 # supportsAllDrives=True,
                 # includeItemsFromAllDrives=True,
                 # corpora='allDrives',
            ).execute()
            
            items.extend(response.get('files', []))
            page_token = response.get('nextPageToken', None)
            if page_token is None:
                break
            time.sleep(0.1) 
        except HttpError as error:
            print(f"An error occurred during list_items: {error}")
            break 
    return items

def create_folder(service, name, parent_id):
    # ... (implementation as before) ...
    try:
        folder_metadata = {
            'name': name,
            'mimeType': 'application/vnd.google-apps.folder',
            'parents': [parent_id]
        }
        folder = service.files().create(body=folder_metadata, fields='id').execute()
        print(f"Created folder '{name}' with ID: {folder.get('id')}")
        return folder.get('id')
    except HttpError as error:
        print(f"An error occurred creating folder '{name}': {error}")
        return None

def create_shortcut(service, target_id, shortcut_name, parent_id):
     # ... (implementation as before) ...
    try:
        shortcut_metadata = {
            'name': shortcut_name,
            'mimeType': 'application/vnd.google-apps.shortcut',
            'shortcutDetails': {
                'targetId': target_id
            },
            'parents': [parent_id]
        }
        shortcut = service.files().create(body=shortcut_metadata, fields='id').execute()
        print(f"  Created shortcut '{shortcut_name}' -> {target_id} (ID: {shortcut.get('id')})")
        return shortcut.get('id')
    except HttpError as error:
        print(f"An error occurred creating shortcut for target '{target_id}': {error}")
        return None


def process_drive_structure():
    """Main function to process the Drive structure and create shortcuts."""
    creds = authenticate() # Calls the new authenticate function
    if not creds:
        print("Authentication failed or credentials invalid. Exiting.")
        exit(1) 
        
    try:
        service = build('drive', 'v3', credentials=creds)
        print("Successfully authenticated and built Drive service.")
        
        # ... (rest of the function remains the same as the previous version) ...
        processed_files_count = 0 
        print(f"Looking for artist folders in source root: {SOURCE_ROOT_FOLDER_ID}")
        artist_query = f"'{SOURCE_ROOT_FOLDER_ID}' in parents and mimeType = 'application/vnd.google-apps.folder' and trashed = false"
        artist_folders = list_items(service, artist_query)
        
        if not artist_folders:
            print("No artist folders found in the source directory.")
            return 

        print(f"Found {len(artist_folders)} potential artist folders.")

        for artist_folder in artist_folders:
            artist_name = artist_folder.get('name')
            artist_id = artist_folder.get('id')
            print(f"\nProcessing Artist: {artist_name} (ID: {artist_id})")

            singles_folder_id = None
            singles_query = f"'{artist_id}' in parents and name = '{SINGLES_FOLDER_NAME}' and mimeType = 'application/vnd.google-apps.folder' and trashed = false"
            items_in_artist_folder = list_items(service, singles_query, fields="files(id)") 
            
            if items_in_artist_folder:
                 singles_folder_id = items_in_artist_folder[0].get('id')
                 print(f"  Found '{SINGLES_FOLDER_NAME}' folder (ID: {singles_folder_id})")
            else:
                print(f"  No folder named '{SINGLES_FOLDER_NAME}' found for this artist. Skipping.")
                continue 

            target_folder_name = f"{artist_name} - {SINGLES_FOLDER_NAME}"
            target_singles_folder_id = create_folder(service, target_folder_name, TARGET_ROOT_FOLDER_ID)
            
            if not target_singles_folder_id:
                print(f"  Failed to create target folder '{target_folder_name}'. Skipping songs for this artist.")
                continue 

            songs_query = f"'{singles_folder_id}' in parents and mimeType != 'application/vnd.google-apps.folder' and trashed = false"
            songs = list_items(service, songs_query, fields="nextPageToken, files(id, name)")

            if not songs:
                 print(f"  No songs found in the source '{SINGLES_FOLDER_NAME}' folder.")
                 continue

            print(f"  Found {len(songs)} songs in source '{SINGLES_FOLDER_NAME}' folder. Creating shortcuts...")

            for song in songs:
                song_id = song.get('id')
                song_name = song.get('name')
                
                if create_shortcut(service, song_id, song_name, target_singles_folder_id):
                    processed_files_count += 1
                
                time.sleep(0.2) 

        print(f"\nFinished processing. Total shortcuts created in this run: {processed_files_count}")


    except HttpError as error:
        print(f'An API error occurred: {error}')
        exit(1) 
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        exit(1) 

if __name__ == '__main__':
    process_drive_structure()
    print("\nScript finished successfully.") # Only reached if no exit(1) was called